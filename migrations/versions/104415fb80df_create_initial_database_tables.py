# --- START OF FILE 104415fb80df_create_initial_database_tables.py --- (KORRIGIERT)

"""Create initial database tables

Revision ID: 104415fb80df 
Revises: 
Create Date: 2025-05-28 23:23:28.220069 # Dein Zeitstempel

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '104415fb80df' # Dein Revisions-Hash
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - MANUELL ANGEPASST ###
    
    # 1. Users zuerst erstellen, da andere davon abhängen
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=64), nullable=False),
    sa.Column('email', sa.String(length=120), nullable=False),
    sa.Column('password_hash', sa.String(length=256), nullable=True),
    sa.Column('role', sa.String(length=20), nullable=False),
    sa.Column('team_id', sa.Integer(), nullable=True), # Dieses team_id verweist auf teams.id, wird aber hier noch nicht als FK gesetzt, da teams noch nicht existiert
    sa.PrimaryKeyConstraint('id')
    )
    # Indexe für users erstellen (kann direkt nach der User-Tabelle erfolgen)
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.create_index(batch_op.f('ix_users_email'), ['email'], unique=True)
        batch_op.create_index(batch_op.f('ix_users_username'), ['username'], unique=True)

    # 2. Teams erstellen (kann jetzt users.id referenzieren, wenn team_leader_id gesetzt wird)
    op.create_table('teams',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('team_leader_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['team_leader_id'], ['users.id'], ), # FK zu users
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    
    # Nachträglich den FK von users.team_id zu teams.id hinzufügen
    # Dies ist nötig, weil users.team_id auf teams.id verweist, aber teams beim Erstellen von users noch nicht existierte.
    # Diese Art von "zweiseitigem FK" ist knifflig für Alembic.
    # Es ist besser, wenn die Beziehung nur in eine Richtung im Modell definiert ist oder der FK später hinzugefügt wird.
    # In unserem Fall ist users.team_id die ID des Teams, dem der User als Teamleiter vorsteht.
    # Und teams.team_leader_id ist die ID des Users, der das Team leitet. Das ist redundant.
    # WIR HABEN DAS PROBLEM BEI UNSEREN MODELLEN:
    # User.team_id = db.Column(db.Integer, db.ForeignKey('teams.id'), nullable=True)
    # Team.team_leader_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    # Dies erzeugt eine zirkuläre Abhängigkeit auf Datenbankebene für FKs, wenn beide gesetzt werden.
    #
    # OPTIONALE ANPASSUNG FÜR SAUBERERE FKs (empfohlen für die Zukunft, aber für jetzt lassen wir es so, wie Alembic es generiert hat, und fügen den FK später hinzu):
    # Alembic hat den FK für User.team_id NICHT automatisch erstellt, was gut ist.
    # Er wird nur den FK von Team.team_leader_id zu User.id erstellen.
    # Das ist OK für den Moment. Die Redundanz wird in der App-Logik gehandhabt.
    # Wenn wir den FK von users.team_id zu teams.id auch auf DB-Ebene wollten:
    # with op.batch_alter_table('users', schema=None) as batch_op:
    #     batch_op.create_foreign_key(
    #         "fk_users_team_id_teams", # Name des Constraints
    #         'teams', # Referenzierte Tabelle
    #         ['team_id'], # Lokale Spalte(n)
    #         ['id'] # Remote Spalte(n)
    #     )
    # DA DER OBIGE CODE VON ALEMBIC DEN FK BEI USERS NICHT HAT, IST DIE AKTUELLE GENERIERUNG OKAY FÜR DEN USER FK.

    # 3. TeamMembers erstellen (hängt von teams ab)
    op.create_table('team_members',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=100), nullable=False),
    sa.Column('team_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['team_id'], ['teams.id'], ),
    sa.PrimaryKeyConstraint('id')
    )

    # 4. Coachings erstellen (hängt von users und team_members ab)
    op.create_table('coachings',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('team_member_id', sa.Integer(), nullable=False),
    sa.Column('coach_id', sa.Integer(), nullable=False),
    sa.Column('coaching_date', sa.DateTime(), nullable=False),
    sa.Column('coaching_style', sa.String(length=50), nullable=True),
    sa.Column('tcap_id', sa.String(length=50), nullable=True),
    sa.Column('leitfaden_begruessung', sa.String(length=10), nullable=True),
    sa.Column('leitfaden_legitimation', sa.String(length=10), nullable=True),
    sa.Column('leitfaden_pka', sa.String(length=10), nullable=True),
    sa.Column('leitfaden_kek', sa.String(length=10), nullable=True),
    sa.Column('leitfaden_angebot', sa.String(length=10), nullable=True),
    sa.Column('leitfaden_zusammenfassung', sa.String(length=10), nullable=True),
    sa.Column('leitfaden_kzb', sa.String(length=10), nullable=True),
    sa.Column('performance_mark', sa.Integer(), nullable=True),
    sa.Column('time_spent', sa.Integer(), nullable=True),
    sa.Column('project_leader_notes', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['coach_id'], ['users.id'], ),
    sa.ForeignKeyConstraint(['team_member_id'], ['team_members.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - MANUELL ANGEPASST (umgekehrte Reihenfolge) ###
    op.drop_table('coachings')
    op.drop_table('team_members')
    # Kein FK von users.team_id zu droppen, da er nicht erstellt wurde.
    op.drop_table('teams') # Muss vor users gedroppt werden, da users keinen FK mehr zu teams hat (in dieser generierten Version)
    
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.drop_index(batch_op.f('ix_users_username'))
        batch_op.drop_index(batch_op.f('ix_users_email'))
    op.drop_table('users')
    # ### end Alembic commands ###